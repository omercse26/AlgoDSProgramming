#include <utility>
#include <functional>

template <int I>
struct placeholder {};

template <typename T>
struct Bind
{
  	template <typename... Args>
	constexpr decltype(auto) operator() (Args && ... param) const
    {
      return t(std::forward<decltype(param)>(param)...);
    }
  
  	T t;
};

template <int I, typename T>
constexpr decltype(auto) getparam(const placeholder<I>&,  T&& t)
{
  return std::get<I>(t);
}

template <typename P, typename T>
constexpr decltype(auto) getparam(P &&p, T&&)
{
  return std::forward<P>(p);
}

template <typename P, typename T>
constexpr decltype(auto) getparam(const Bind<P>& b, T&& t)
{
 return std::apply(b, std::forward<T>(t)); 
}

constexpr auto bind = [](auto&& c, auto && ... p)
{
  return Bind {
      [ c = std::forward<decltype(c)>(c),
        ... p
      ]
      (auto && ... v)
    {
      
    }
  };
};

int main()
{
    constexpr auto _0 = placeholder<0>{};
    constexpr auto _1 = placeholder<1>{};
}

/*
workaround to capture parameter packs in a lambda
https://stackoverflow.com/questions/47496358/c-lambdas-how-to-capture-variadic-parameter-pack-from-the-upper-scope?rq=1

*/
