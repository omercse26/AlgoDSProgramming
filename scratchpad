#include <cstdio>
#include <variant>
#include <array>
#include <type_traits>
#include <iomanip>

template <unsigned long size, typename Key, typename ParentCache, typename ...Types>
struct cache
{
  // sizeof(std::variant<Types...>) can be more than the size of the largest type 
  // due to alignment reasons.
  
  struct cache_content
  {
    bool dirty_bit;
    bool valid;
    std::variant<Types...> data;
  };
  
  constexpr static auto array_size = size/sizeof(cache_content);
  std::array<cache_content, array_size> contents;
  
  auto getIndex(Key key)
  {
    if constexpr (std::is_arithmetic_v<Key>)
    {
      return static_cast<unsigned long>(key) % array_size;
    }
    else if constexpr (std::is_same_v<Key, std::string>)
    {
      // djb2
      unsigned long hash = 5381;
      for (auto ch : key) 
      {
          hash = (hash << 5) + hash + ch; /* hash * 33 + c */
      }
      return hash % array_size;
    }
  }
  
  auto fetch(Key key)
  {
    auto index = getIndex(key);
    return contents[index].data;
  }
};

int main()
{
    cache<1024, int, float> c;
    c.fetch(10);
}




#include <cstdio>
#include <iostream>

template <int I>
struct s : private s<I-1>
{
  void print()
  {
     s<I-1>::print();
  }
};

template<>
struct s<0>
{
   void print()
   {
      std::cout << 0;
   		//s<1>::print();
   }
};

int main()
{
    s<2> ss;
   ss.print();
}

=======================================================================================================
#include <iostream>
#include <array>
#include <type_traits>
#include <optional>

template <typename Key, typename Value, int size>
struct MemoryModel 
{
  struct cache_content
  {
    bool dirty_bit;
    bool valid;
    Value data;
  };
  
  constexpr static auto array_size = size/sizeof(cache_content);
  std::array<cache_content, array_size> contents;
  
  auto getIndex(Key key)
  {
    if constexpr (std::is_arithmetic_v<Key>)
    {
      return static_cast<unsigned long>(key) % array_size;
    }
    else if constexpr (std::is_same_v<Key, std::string>)
    {
      // djb2
      unsigned long hash = 5381;
      for (auto ch : key) 
      {
          hash = (hash << 5) + hash + ch; /* hash * 33 + c */
      }
      return hash % array_size;
    }
  }
  
  virtual std::optional<Value> fetch (Key key) = 0;
  virtual bool store(Key key, Value value) = 0;
  
  virtual ~MemoryModel() {}
};

template <typename Key, typename Value, int size>
struct CacheModel : MemoryModel<Key, Value, size>
{
    using MemoryModel<Key, Value, size>::contents;
    using MemoryModel<Key, Value, size>::getIndex;
	std::optional<Value> fetch (Key key)
    {
    	auto index = getIndex(key);
        if (contents[index].valid)
        {
        	return contents[index].data;
        }
        
        return std::nullopt;
    }
    
    bool store(Key key, Value value)
    {
    	auto index = getIndex(key);
        contents[index].data = value;
        contents[index].dirty_bit = true;
        contents[index].valid = true;
        return true;
    }
};

template <typename Key, typename Value, int I, int  ...sizes>
struct MultiLevelCache : MultiLevelCache<Key, Value, sizes...>
{
   using MM = CacheModel<Key, Value, I>;
   MM m;
   
   //void fetch(K
};

template <typename Key, typename Value, int I>
struct MultiLevelCache<Key, Value, I>
{
   using MM = CacheModel<Key, Value, I>;
   MM m;
};

template <typename Key, typename Value, typename ...Sizes>
constexpr auto generate_multilevel_cache(const Sizes... cachesizelist)
{
  return MultiLevelCache<Key, Value, cachesizelist...>();
}


int main()
{ 
   //MultiLevelCache<int, int, 1024, 4096> mm;
   auto m = generate_multilevel_cache<int, int>(1024, 4096);
}
